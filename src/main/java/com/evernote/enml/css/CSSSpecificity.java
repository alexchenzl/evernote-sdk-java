/**
 * Copyright 2015 Evernote Corporation.
 */
package com.evernote.enml.css;

import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.helger.css.decl.CSSDeclaration;
import com.helger.css.decl.CSSSelector;
import com.helger.css.decl.CSSSelectorAttribute;
import com.helger.css.decl.CSSSelectorMemberFunctionLike;
import com.helger.css.decl.CSSSelectorMemberNot;
import com.helger.css.decl.CSSSelectorSimpleMember;
import com.helger.css.decl.ICSSSelectorMember;

public class CSSSpecificity implements Comparable<Object> {

  private int[] specificity;
  private static final Pattern CSS_SPECIFICITY_PATTERN = Pattern.compile(
      "\\[\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\]");

  public CSSSpecificity(int[] specificity) {
    this.specificity = specificity;
  }

  public CSSSpecificity(CSSSelector selector, CSSDeclaration declaration) {
    if (selector == null) {
      this.specificity = calculateSpecificity(declaration);
    } else {
      this.specificity = calculateSpecificity(selector, declaration);
    }
  }

  public CSSSpecificity(CSSDeclaration declaration) {
    this.specificity = calculateSpecificity(declaration);
  }

  public boolean isInlineStyle() {
    if (specificity != null && specificity[1] > 0) {
      return true;
    }
    return false;
  }

  /**
   * Compares this declaration's specificity to another. Possible types for o are
   * CSSSingleSelectorDeclaration or int[]
   * 
   * @see java.lang.Comparable#compareTo(java.lang.Object)
   */
  public int compareTo(Object o) {
    if (o instanceof CSSSpecificity) {
      CSSSpecificity cssd = (CSSSpecificity) o;
      for (int i = 0; i < specificity.length; i++) {
        if (specificity[i] > cssd.specificity[i]) {
          return 1;
        } else if (specificity[i] < cssd.specificity[i]) {
          return -1;
        }
      }
      return 0;
    } else if (o.getClass().isArray()) {
      int[] spec = (int[]) o;
      for (int i = 0; i < specificity.length; i++) {
        if (specificity[i] > spec[i]) {
          return 1;
        } else if (specificity[i] < spec[i]) {
          return -1;
        }
      }
      return 0;
    }

    throw new ClassCastException("Can only compare CSSSpecificity or int[]");
  }

  /**
   * Calculates this declaration's specificity according to
   * http://www.w3.org/TR/CSS2/cascade.html#specificity
   * 
   * @param sel selector
   * @param decl declaration
   * @return specificity (five element array of ints)
   */
  private int[] calculateSpecificity(CSSSelector sel, CSSDeclaration decl) {
    int[] spec = {0, 0, 0, 0, 0};
    if (decl.isImportant()) {
      spec[0] = 1;
    }
    List<ICSSSelectorMember> members = sel.getAllMembers();
    for (ICSSSelectorMember m : members) {
      if (m instanceof CSSSelectorAttribute) {
        spec[3]++;
      } else if (m instanceof CSSSelectorMemberFunctionLike) {
        spec[4]++;
      } else if (m instanceof CSSSelectorMemberNot) {
        CSSSelectorMemberNot member = (CSSSelectorMemberNot) m;
        // multiple selectors within a :not is not valid CSS and browsers don't render
        // the rule
        if (member.getSelectorCount() == 1) {
          CSSSelector innerSel = member.getSelectorAtIndex(0);
          int[] innerSpec = calculateSpecificity(innerSel, decl);
          // don't start at 0 so it doesn't double count the !important slot
          for (int i = 1; i < spec.length; i++) {
            spec[i] += innerSpec[i];
          }
        }
      } else if (m instanceof CSSSelectorSimpleMember) {
        CSSSelectorSimpleMember member = (CSSSelectorSimpleMember) m;
        if (!member.getValue().equals("*")) {
          if (member.isHash()) {
            spec[2]++;
          } else if (member.isClass() || member.isPseudo()) {
            spec[3]++;
          } else if (member.isElementName()) {
            spec[4]++;
          }
        }
      }
    }
    return spec;
  }

  /**
   * Calculates this declaration's specificity according to
   * http://www.w3.org/TR/CSS2/cascade.html#specificity. This is used for declarations
   * that were declared inline, so they do not have a selector
   * 
   * @param decl declaration
   * @return specificity (five element array of ints)
   */
  public int[] calculateSpecificity(CSSDeclaration decl) {
    int[] spec = {0, 1, 0, 0, 0};
    if (decl.isImportant()) {
      spec[0] = 1;
    }
    return spec;
  }

  public int[] getSpecificity() {
    return specificity;
  }

  /**
   * Converts a string representation of an int[] into an int[].
   * 
   * @param s string representation. should be of the format generated by
   *          Arrays.toString(int[])
   * @return specificity (int[5]), or null if s was not a valid string
   */
  public static CSSSpecificity parseAsCSSSpecificity(String s) {
    try {
      int[] spec = new int[5];
      Matcher m = CSS_SPECIFICITY_PATTERN.matcher(s);
      if (m.find()) {
        for (int i = 1; i <= m.groupCount(); i++) {
          spec[i - 1] = Integer.parseInt(m.group(i), 10);
        }
        return new CSSSpecificity(spec);
      }
      return null;
    } catch (NumberFormatException e) {
      return null;
    }
  }

}
